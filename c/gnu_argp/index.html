<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="description" content=Aloha!&#32;Welcome&#32;to&#32;cheon&#39;s&#32;blog.>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="apple-touch-icon" sizes= "76x76" href=https://www.cheon.site/blog/img/apple-touch-icon.png>
    <link rel="icon" href=https://www.cheon.site/blog/img/pen.svg>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/global.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/nav.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/header.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/index.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/list.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/single.css>
    <link rel="stylesheet" href=https://www.cheon.site/blog/css/footer.css>
    
    <link href="https://fonts.googleapis.com/css?family=Fira+Mono|Noto+Sans+SC|Old+Standard+TT&display=swap" rel="stylesheet">
    
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <title>cheon&#39;s blog</title>

</head>
<body><section id="header">
    <ul id="menus">
    
    <li class="menu"><a href="https://www.cheon.site"><span>Home</span></a></li>
    
    <li class="menu"><a href="https://www.cheon.site/blog/categories"><span>Categories</span></a></li>
    
    <li class="menu"><a href="https://www.cheon.site/blog/tags"><span>Tags</span></a></li>
    
    <li class="menu"><a href="https://github.com/number317"><span>Projects</span></a></li>
    
    </ul>
    <h1 id="title"><a href="https://www.cheon.site/blog/">cheon&#39;s blog</a></h1>
</section>
<ul class="nav">






<li>
    »
    <a href="https://www.cheon.site/blog/">
    
    cheon&#39;s blog
    
    </a>
</li>


<li>
    »
    <a href="https://www.cheon.site/blog/c/">
    
    c
    
    
    </a>
</li>


<li class="active">
    »
    <a href="https://www.cheon.site/blog/c/gnu_argp/">
    
    GNU Argp
    
    </a>
</li>

</ul>

<div>
<section id="main">
  <h1>GNU Argp</h1>
  <time>Last updated Mon Dec 30, 2019</time>
  <div>
      <article id="content">
          

<h1 id="table-of-contents">Table of Contents</h1>

<ol>
<li><a href="#orga87ae77">GNU Argp 库</a>

<ol>
<li><a href="#org35b9baa">前置知识</a>

<ol>
<li><a href="#org04f03df">从一个示例开始</a></li>
<li><a href="#org2ee364e">命令行参数</a></li>
<li><a href="#org09e2c5f">选项的参数</a></li>
</ol></li>
<li><a href="#orga58fb28">step0: 第一个 argp 程序</a></li>
<li><a href="#org5160012">step1: 短选项</a></li>
<li><a href="#org7d255da">step2: 选项参数</a></li>
<li><a href="#org4b6cffa">step3: 长选项</a></li>
<li><a href="#orgf0f8ac6">step4: 可选项</a></li>
<li><a href="#org80f9f9d">step5: 别名</a></li>
<li><a href="#orgd3f09ca">step6: 回调自身</a></li>
<li><a href="#orgc912c26">step7: 参数支持</a></li>
<li><a href="#org7164976">step8: 隐藏选项</a></li>
<li><a href="#org4c6f6b6">step9: 完善说明</a></li>
<li><a href="#orgc31acea">step10: 选项组</a></li>
<li><a href="#org68f9698">step11: 调用库</a></li>
</ol></li>
</ol>

<p><a id="orga87ae77"></a></p>

<h1 id="gnu-argp-库">GNU Argp 库</h1>

<p>c 命令行程序中的参数处理是很常见的需求，要做到这点我们可以用 GNU 的标准库 argp，大部分 GNU 组件都用这个库来解析参数。</p>

<p><a id="org35b9baa"></a></p>

<h2 id="前置知识">前置知识</h2>

<p><a id="org04f03df"></a></p>

<h3 id="从一个示例开始">从一个示例开始</h3>

<p>先来看一个例子:</p>

<p><details>
<summary> <code>sum --help</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">sum --help
Usage: sum [OPTION]... [FILE]...
Print checksum and block counts for each FILE.

With no FILE, or when FILE is -, read standard input.

  -r              use BSD sum algorithm, use 1K blocks
  -s, --sysv      use System V sum algorithm, use 512 bytes blocks
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/sum&gt;
or available locally via: info &#39;(coreutils) sum invocation&#39;</pre></div>
<p></details></p>

<p>这是一个调用 <code>--help</code> 选项常见的输出。受到 BNF 影响， <code>[]</code> 意味着是可选的项， <code>...</code> 意味着是可重复的项。因此上面的输出意味着 <code>sum</code> 命令可以有 0 个或多个选项，可以有 0 个或多个文件。</p>

<p><a id="org2ee364e"></a></p>

<h3 id="命令行参数">命令行参数</h3>

<p>大多数命令行程序可以有参数(arguments)和选项(options)。参数可以是文件名，就像在 <code>cp</code> 命令中看到的:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">cp -v foo bar</pre></div>
<p>有些时候，一个参数看起来很像一个选项。例如，你可能有一个目录，名为 <code>--foo</code> ，现在你想要删除它。运行 <code>rmdir --foo</code> 将会导致 <code>rmdir</code> 程序报告没有 <code>--foo</code> 选项的错误。因为这个参数是无法和长选项区分的，我们需要为程序提供一个指示说明我们提供的是参数而不是选项。要做到这点，我们可以使用 <code>--</code> 来告诉程序不再有更多的参数提供给程序:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">mkdir --foo
mkdir: unrecognized option &#39;--foo&#39;
Try &#39;mkdir --help&#39; for more information.

mkdir -- --foo

rmdir --foo
rmdir: unrecognized option &#39;--foo&#39;
Try &#39;rmdir --help&#39; for more information.

rmdir -- --foo</pre></div>
<p><code>--</code> 的使用在 argp 库中是默认的处理行为。</p>

<p><a id="org09e2c5f"></a></p>

<h3 id="选项的参数">选项的参数</h3>

<p>和程序一样，选项（通常是长选项）也可以有参数。参数可以是强制参数，可选参数，或者没有参数:</p>

<p><details>
<summary> <code>fold --help</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">fold --help
Usage: fold [OPTION]... [FILE]...
Wrap input lines in each FILE, writing to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --bytes         count bytes rather than columns
  -s, --spaces        break at spaces
  -w, --width=WIDTH   use WIDTH columns instead of 80
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/fold&gt;
or available locally via: info &#39;(coreutils) fold invocation&#39;</pre></div>
<p></details></p>

<p>可以看到 <code>--width</code> 选项需要一个数字作为参数。使用 <code>--width</code> 选项而不提供参数是错误的，可以有多种方式为 <code>--width</code> 选项提供参数:</p>

<p><details>
<summary> <code>folder</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">echo &#34;hello there&#34; | fold -w3
hel
lo 
the
re

echo &#34;hello there&#34; | fold -w 4
hell
o th
ere

echo &#34;hello there&#34; | fold --width 5
hello
 ther
e

echo &#34;hello there&#34; | fold --width=6
hello 
there</pre></div>
<p></details></p>

<p>带参数的短选项是值得注意的，这不怎么常见，一个例子是 GNU Make 的 <code>-j</code> 参数:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">-j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.
-k, --keep-going            Keep going when some targets can&#39;t be made.</pre></div>
<p>需要值得注意的地方是这种类型的选项可以和 <code>-k</code> 一起使用，但不能是 <code>-k</code> 在 <code>-j</code> 之后。即 make -kj 可以正常工作，但 make -jk 不能。因为这里的 k 被认为是 -j 的参数，而 k 作为 j 的参数是不合法的，它明显不是个数字。</p>

<p><a id="orga58fb28"></a></p>

<h2 id="step0-第一个-argp-程序">step0: 第一个 argp 程序</h2>

<p>step0.c:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;argp.h&gt;

int main(int argc, char **argv) {
  return argp_parse(0, argc, argv, 0, 0, 0);
}</pre></div>
<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step0

./step0 --help
Usage: step0 [OPTION...]

  -?, --help                 Give this help list
      --usage                Give a short usage message

./step0 --usage
Usage: step0 [-?] [--help] [--usage]

./step0 foo
step0: Too many arguments
Try `step0 --help&#39; or `step0 --usage&#39; for more information.

./step0 --us
Usage: step0 [-?] [--help] [--usage]

./step0 --foo
./step0: unrecognized option &#39;--foo&#39;
Try `step0 --help&#39; or `step0 --usage&#39; for more information.

./step0 --usage --help
Usage: step0 [-?] [--help] [--usage]</pre></div>
<p></details></p>

<p>通过测试证明以下几件事:</p>

<ol>
<li>argp 自动做了一些错误处理，默认不允许任何参数</li>
<li>我们可以使用 <code>-us</code> 代替 <code>--usage</code> 并且效果相同</li>
<li>对于系统不识别的选项做了错误处理</li>
<li>用 <code>--</code> 说明命令行的选项结束</li>
</ol>

<p><a id="org5160012"></a></p>

<h2 id="step1-短选项">step1: 短选项</h2>

<p>为之前的程序添加一个 <code>-d</code> 选项，是程序在屏幕上打印一个 <code>.</code> :</p>

<p><detail>
<summary> <code>step1.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;argp.h&gt;
#include &lt;stdio.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
  switch(key) {
  case &#39;d&#39;:
    printf(&#34;.\n&#34;);
    break;
  }
  return 0;
}

int main(int argc, char **argv) {
  struct argp_option options[] =
    {
     { 0, &#39;d&#39;, 0, 0, &#34;show a dot on the screen&#34;},
     { 0 }
    };
  struct argp argp = { options, parse_opt };
  return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p><code>argp_option</code> 结构体有 5 个字段，为 0 的表示没有用到，第二个字段 <code>-d</code> 表示短选项，第五个字段包含在 <code>--help</code> 选项中显示的描述。
在 argp 中最重要的数据类型是 <code>struct argp</code> 。这里可以看到它包含:</p>

<ol>
<li>所有的选项（现在只有一个）</li>
<li>一个指向 argp 用于解析选项的函数的指针（ <code>parse_opt</code> ）</li>
</ol>

<p>注意到 <code>parse_opt</code> 是一个回调函数，在代码中没有被显示地调用，而是被传递给了 <code>struct argp</code> 作为参数，这里实际是把指向函数所在地址的指针传递给了 <code>struct argp</code> ，这与数组名指向数组的第一个元素类似，如果查看 argp 的源码可以看到 <code>parse_opt</code> 被重复地调用来处理每一个选项和参数。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step1

./step1 --help
Usage: step1 [OPTION...]

  -d                         show a dot on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step1 -d
.

./step1 -ddd -d
.
.
.
.</pre></div>
<p></details></p>

<p><a id="org7d255da"></a></p>

<h2 id="step2-选项参数">step2: 选项参数</h2>

<p>现在为 <code>-d</code> 选项添加一个参数，好让程序输出更多的 <code>.</code> 而不是一个。</p>

<p><details>
<summary> <code>step2.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            for(i=0; i&lt;atoi(arg); i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { 0, &#39;d&#39;, &#34;NUM&#34;, 0, &#34;Show some dots on the screen&#34;},
        { 0 }
    };

    struct argp argp = { options. parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p>现在用到了 <code>argp_option</code> 的第三个字段，这表明 <code>-d</code> 选项有一个名为 <code>NUM</code> 的参数，这会在 <code>--help</code> 和 <code>--usage</code> 中显示。如果把这个字段改回 <code>0</code> 或 <code>NULL</code> ， <code>-d</code> 选项会停止接受强制参数。</p>

<p>在 <code>parse_opt</code> 回调函数中，使用了 <code>arg</code> 参数。它是字符串类型，不能为 <code>NULL</code> 因为 argp 不允许没有参数调用 <code>-d</code> 。 <code>arg</code> 指向没有申请过的内存，尝试去强制释放它不是一个好主意。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step2

./step2 --help
Usage: step2 [OPTION...]

  -d NUM                     Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step2 -d1 -d2 -d 3
.
..
...

./step2 -d
./step2: option requires an argument -- &#39;d&#39;
Try `step2 --help&#39; or `step2 --usage&#39; for more information.

./step2 --usage
Usage: step2 [-?] [-d NUM] [--help] [--usage]</pre></div>
<p></details></p>

<p><a id="org4b6cffa"></a></p>

<h2 id="step3-长选项">step3: 长选项</h2>

<p>现在为 <code>-d</code> 选项添加一个等价的长选项 <code>--dot</code> 。</p>

<p><details>
<summary> <code>step3.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            for(i=0; i&lt;atoi(arg); i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, 0, &#34;Show some dots on the screen&#34;},
        { 0 }
    };
    struct argp argp = { options, parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p><code>struct argp_option</code> 的第一个字段控制长选项的名字。如果在选项名字中有空格，新行，tab 或不可打印的字符，会报错。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step3

./step3 --help
Usage: step3 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

./step3 --dot 1 --dot=2 -d3
.
..
...

./step3 --dot
./step3: option &#39;--dot&#39; requires an argument
Try `step3 --help&#39; or `step3 --usage&#39; for more information.

./step3 --do 12
............

./step3 --usage
Usage: step3 [-?] [-d NUM] [--dot=NUM] [--help] [--usage]</pre></div>
<p></details></p>

<p>现在可以看到 <code>--help</code> 信息中有了 <code>--dot</code> 选项。在 help 信息底部有一个唠叨的信息，告诉你 <code>NUM</code> 也是短选项 <code>-d</code> 的参数。可以设置环境变量 <code>ARGP_HELP_FMT</code> 的值为 <code>no-dup-args-note</code> 来关闭这个信息。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">export ARGP_HELP_FMT=&#34;no-dup-args-note&#34;

./step3 --help
Usage: step3 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message</pre></div>
<p><a id="orgf0f8ac6"></a></p>

<h2 id="step4-可选项">step4: 可选项</h2>

<p>现在将 <code>--dot</code> 的 <code>NUM</code> 参数设置为可选的。</p>

<p><details>
<summary> <code>step4.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i=0; i&lt;dots; i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34;},
        { 0 }
    };
    struct argp argp = { options, parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p><code>struct argp_option</code> 的第四个字段设置选项如何工作。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step4

./step4 --help
Usage: step4 [OPTION...]

  -d, --dot[=NUM]            Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step4 --usage
Usage: step4 [-?] [-d[NUM]] [--dot[=NUM]] [--help] [--usage]

./step4 -d --dot=3 --dot
.
...
.

./step4 --dot 3
.

./step4 -dd</pre></div>
<p></details></p>

<p>最后两个例子可能不符合预期，这是因为长选项配合可选参数需要一个 <code>=</code> 放在选项和参数之间，如果没有，参数会被认为是程序的参数，而不是选项的参数。带有可选参数的短选项不能连起来用。第二个 <code>d</code> 被认为是第一个 <code>d</code> 的参数， <code>atoi</code> 将 <code>-d</code> 转换为 <code>0</code> 。</p>

<p><a id="org80f9f9d"></a></p>

<h2 id="step5-别名">step5: 别名</h2>

<p><details>
<summary> <code>step5.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34; },
         { &#34;period&#34;, 0, &#34;FOO&#34;, OPTION_ALIAS, &#34;Bar&#34; },
         { 0 }
        };
    struct argp argp = { options, parse_opt, 0, 0};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p><code>OPTION_ALIAS</code> 使得选项继承前一个选项的所有字段，除了第一字段长选项名和第二字段短选项名。可以有任意多个别名。一些字段被随意填充了值来阐明它们其实被 argp 忽略了。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step5

./step5 --help
Usage: step5 [OPTION...]

  -d, --dot[=NUM], --period[=NUM]
                             Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step5 --usage
Usage: step5 [-?] [-d[NUM]] [--dot[=NUM]] [--period[=FOO]] [--help] [--usage]

./step5 --period
.

./step5 --period=4
....</pre></div>
<p></details></p>

<p>可以看到 <code>FOO</code> 和 <code>Bar</code> 被正确地忽略了，没有在 help 信息中显示出来。新的长选项 <code>--period</code> 出现在 <code>--dot=</code> 选项旁因为它们是完全等价的。</p>

<p><a id="orgd3f09ca"></a></p>

<h2 id="step6-回调自身">step6: 回调自身</h2>

<p>现在为程序添加一个长选项 <code>--ellipsis</code> 用于在屏幕输出 3 个点。功能上等价于 <code>--dot=3</code> :</p>

<p><details>
<summary> <code>step6.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
        case 777:
            return parse_opt(&#39;d&#39;, &#34;3&#34;, state);
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, 0, &#34;Show some dots on the screen&#34; },
         { &#34;ellipsis&#34;, 777, 0, 0, &#34;Show an ellipsis on the screen&#34; },
         { 0 }
        };
    struct argp argp = { options, parse_opt, 0, 0};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p>可以看到 <code>--ellipsis</code> 选项不接收任何参数，并且有一个奇怪的短选项 <code>777</code> 。这是因为 argp 自动检测短选项是否是可打印的字符，由于 <code>777</code> 不是一个可打印的字符，意味着 <code>--ellipsis</code> 没有对应等价的短选项。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step6

./step6 --help
Usage: step6 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
      --ellipsis             Show an ellipsis on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step6 --usage
Usage: step6 [-?] [-d NUM] [--dot=NUM] [--ellipsis] [--help] [--usage]

./step6 --ellipsis
...

./step6 --dot 3
...</pre></div>
<p></details></p>

<p>由于 <code>--ellipsis</code> 没有参数，所以无法为它创建一个别名。</p>

<p><a id="orgc912c26"></a></p>

<h2 id="step7-参数支持">step7: 参数支持</h2>

<p>现在为程序添加对一到四个参数的支持。如果程序没有获得足够的参数，将会报错。</p>

<p><details>
<summary> <code>step7.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    int *arg_count = state-&gt;input;
    switch(key) {
        case &#39;d&#39;: {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&#34;.&#34;);
            printf(&#34;\n&#34;);
            break;
        }
        case 777:
            return parse_opt(&#39;d&#39;, &#34;3&#34;, state);
        case ARGP_KEY_ARG:
            {
                (*arg_count)--;
                if(*arg_count &gt;= 0)
                    printf(&#34; %s&#34;, arg);
            }
            break;
        case ARGP_KEY_END:
            {
                printf(&#34;\n&#34;);
                if(*arg_count &gt;=4)
                    argp_failure(state, 1, 0, &#34;too few arguments&#34;);
                else if(*arg_count &lt; 0)
                    argp_failure(state, 1, 0, &#34;too many arguments&#34;);
            }
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, 0, &#34;Show some dots on the screen&#34; },
         { &#34;ellipsis&#34;, 777, 0, 0, &#34;Show an ellipsis on the screen&#34; },
         { 0 }
        };
    int arg_count = 4;
    struct argp argp = { options, parse_opt, &#34;WORD [WORD [WORD [WORD]]]&#34;};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arg_count);
}</pre></div>
<p></details></p>

<p>在 argp 接收到参数时，它传递 <code>ARGP_KEY_ARG</code> ，当 argp 接收到最后一个参数时，它传递 <code>ARGP_KEY_END</code> 到回调函数。</p>

<p>argp 提供了一个函数 <code>argp_failure</code> 用于参数解析的错误处理，使用这个函数错误信息会有标准的格式。</p>

<p><code>state</code> 参数展示了 <code>input</code> 字段，它存放传递给程序的参数，使用它有两个目的:</p>

<ol>
<li>知道有多少个参数应该春帝给程序</li>
<li>知道有多少个参数传递给程序</li>
</ol>

<p>argp 也追踪目前为止已经处理了多少个参数，这个信息存放在 <code>arg_num</code> 字段中。</p>

<p>代码中也传递了一个指针给 <code>argp_parse</code> 作为第 6 个参数。这个参数可以让你传递你想要的数据给回调函数，这通常是一个结构体。</p>

<p><code>struct argp</code> 也拥有比我们想的更多的字段。第三个字段表示在此命令行中期望的参数。在此例中，期望有四个参数，所以这么写。这里将它们称为 <code>WORD</code> ，因为这符合句子的构造。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step7

./step7 --help

Usage: step7 [OPTION...] WORD [WORD [WORD [WORD]]]

  -d, --dot=NUM              Show some dots on the screen
      --ellipsis             Show an ellipsis on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step7 --usage
Usage: step7 [-?] [-d NUM] [--dot=NUM] [--ellipsis] [--help] [--usage]
            WORD [WORD [WORD [WORD]]]

./step7 once upon a time
 once upon a time

./step7 one tow three four five
 one tow three four
step7: too many arguments</pre></div>
<p></details></p>

<p>首先可以看到参数注解被包含在了 help 和 usage 信息中了，并且用户可以给出一到四个单词作为参数，但不能是没有或者大于四个。</p>

<p>当在命令最后带上 <code>--ellipsis</code> 长参数时， <code>...</code> 会先输出。这是因为 argp 默认行为是先解析选项，再解析参数。如果想要改变，可以向 <code>argp_parse</code> 函数的第四个参数传递 <code>ARGP_IN_ORDER</code> 。</p>

<p><a id="org7164976"></a></p>

<h2 id="step8-隐藏选项">step8: 隐藏选项</h2>

<p>这里要将程序改造成莫尔斯密码的程序，会添加 <code>--dash</code> 选项，改造 <code>--ellipsis</code> 选项。并且选项在 help 和 usage 信息中被隐藏。程序不再接收任何参数。</p>

<p><details>
<summary> <code>step8</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;:
            {
                unsigned int i;
                unsigned int dots = 1;
                if(arg != NULL)
                    dots = atoi(arg);
                for(i=0; i&lt;dots; i++)
                    printf(&#34;.&#34;);
                break;
            }
            break;
        case 888:
            printf(&#34;-&#34;);
            break;
        case 777:
            return parse_opt(&#39;d&#39;, &#34;3&#34;, state);
        case ARGP_KEY_ARG:
            argp_failure(state, 1, 0, &#34;too many arguments&#34;);
            break;
        case ARGP_KEY_END:
            printf(&#34;\n&#34;);
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34; },
         { &#34;ellipsis&#34;, 777, 0, OPTION_HIDDEN, &#34;Show an ellipsis on the screen&#34; },
         { &#34;dash&#34;, 888, 0, 0, &#34;Show a dash on the screen&#34; },
         { 0 }
        };
    int arg_count = 4;
    struct argp argp = { options, parse_opt};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}</pre></div>
<p></details></p>

<p>上述代码中添加了一个长选项 <code>--dash</code> ，给 <code>--dot</code> 选项一个可选的参数，给了 <code>--ellipsis</code> 一个 <code>OPTION_HIDDEN</code> 参数。这可以使改选项继续生效，但不会在 help 和 usage 信息中显示。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step8

./step8 --help
Usage: step8 [OPTION...]

  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step8 --usage
Usage: step8 [-?] [-d[NUM]] [--dot[=NUM]] [--dash] [--help] [--usage]

./step8 --ellipsis
...

./step8 -d -d --dot --dash --dash --dash
...---

./step8 --dash --
-

./step8 --d
./step8: option &#39;--d&#39; is ambiguous; possibilities: &#39;--dot&#39; &#39;--dash&#39;
Try `step8 --help&#39; or `step8 --usage&#39; for more information.

./step8 dot
step8: too many arguments</pre></div>
<p></details></p>

<p><a id="org4c6f6b6"></a></p>

<h2 id="step9-完善说明">step9: 完善说明</h2>

<p><details>
<summary> <code>step9</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &lt;argz.h&gt;
#include &lt;stdlib.h&gt;

const char *argp_program_bug_address = &#34;someone@example.com&#34;;
const char *argp_program_version = &#34;version 1.0&#34;;

struct arguments {
    char *argz;
    size_t argz_len;
};

static int parse_opt(int key, char *arg, struct argp_state *state)
{
    struct arguments *a = state-&gt;input;
    switch(key) {
    case &#39;d&#39;:
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&#34;.&#34;);
            break;
        }
    case 888:
        printf(&#34;-&#34;);
        break;
    case ARGP_KEY_ARG:
        argz_add(&amp;a-&gt;argz, &amp;a-&gt;argz_len, arg);
        break;
    case ARGP_KEY_INIT:
        a-&gt;argz = 0;
        a-&gt;argz_len = 0;
        break;
    case ARGP_KEY_END:
        {
            size_t count = argz_count(a-&gt;argz, a-&gt;argz_len);
            if(count&gt;2)
                argp_failure(state, 1, 0, &#34;too many arguments&#34;);
            else if(count&lt;1)
                argp_failure(state, 1, 0, &#34;too few arguments&#34;);
        }
        break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         {&#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34;},
         {&#34;dash&#34;, 888, 0, 0, &#34;Show a dash on the screen&#34;},
         { 0 }
        };
    struct argp argp = {options, parse_opt, &#34;WORD\nWORD WORD&#34;,
    &#34;Show some dots and dashes on the screen.\v&#34;
    &#34;A final newline is also shown regardless of whether any options were given.&#34;};
    struct arguments arguments;
    if(argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arguments) == 0) {
        const char *prev = NULL;
        char *word;
        while((word = argz_next(arguments.argz, arguments.argz_len, prev))) {
            printf(&#34; %s&#34;, word);
            prev = word;
        }
        printf(&#34;\n&#34;);
        free(arguments.argz);
    }
    return 0;
}</pre></div>
<p></details></p>

<p>如果设置了 <code>argp_program_version</code> ，那么长选项 <code>--version</code> 和短选项 <code>-V</code> 会被包含在程序中。如果设置了 <code>argp_program_bug_address</code> ，help 信息将会添加 <code>Repoprt bugs to: foo@bar..</code> 的信息。对于程序而言，这是一种良好的风格，告诉用户应用版本，以及如何报告 bug。</p>

<p>在上述代码里也用到了 <code>argz</code> 。这是另一个起源与 GNU C 标准库的设施，使用这个库函数来累计程序遇见的参数。结构体 <code>arguments</code> 用于存放参数，它将保留参数，并将其设置为 <code>argp_parse</code> 函数的输入数据挂钩。 <code>stdlib.h</code> 头文件也被引入是因为 argz 向量被分配了内存，需要使用 <code>free</code> 来释放内存。</p>

<p>回调函数中的新元素是 <code>ARGP_KEY_INIT</code> 。它最先被传到回调函数中在任何解析开始之前。这里用于初始化结构体 <code>arguments</code> 。</p>

<p>一个新的 argp 元素是第四个元素，它有特殊的字符 <code>\v</code> ，是一个竖向的制表符。在这个制表符之前的所有内容会显示在选项之前，剩下的会在选项之后显示。这个变量的目的有两方面:</p>

<ol>
<li>给出程序的简短描述</li>
<li>更详细地描述程序的选项和操作</li>
</ol>

<p>另一个新的地方是在 <code>argp</code> 结构体中第三个字段（ <code>args_doc</code> 字段）的换行符。这是告诉用户有其他运行程序的方式的另一种方法。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step9

./step9 --help
Usage: step9 [OPTION...] WORD
  or:  step9 [OPTION...] WORD WORD
Show some dots and dashes on the screen.

  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

A final newline is also shown regardless of whether any options were given.

Report bugs to someone@example.com.

./step9 --usage
Usage: step9 [-?V] [-d[NUM]] [--dot[=NUM]] [--dash] [--help] [--usage]
            [--version] WORD
  or:  step9 [OPTION...] WORD WORD

./step9 foo bar
 foo bar

./step9 foo bar baz
step9: too many arguments

./step9
step9: too few arguments

./step9 foo --dash -d
-. foo

./step9 --version
version 1.0</pre></div>
<p></details></p>

<p>许多命令有许多不同的 usage 行，如 <code>ln</code> 命令有 4 种用法。argp 使处理这种情况变得容易。</p>

<p><a id="orgc31acea"></a></p>

<h2 id="step10-选项组">step10: 选项组</h2>

<p>将 <code>--dash</code> 和 <code>--dot</code> 选项放到自己的组中可以使帮助信息的可读性更高。</p>

<p><details>
<summary> <code>step10</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &lt;argz.h&gt;
#include &lt;stdlib.h&gt;

const char *argp_program_bug_address = &#34;someone@example.com&#34;;
const char *argp_program_version = &#34;version 1.0&#34;;

struct arguments {
    char *argz;
    size_t argz_len;
};

static int parse_opt(int key, char *arg, struct argp_state *state)
{
    struct arguments *a = state-&gt;input;
    switch(key) {
    case &#39;d&#39;:
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&#34;.&#34;);
            break;
        }
    case 888:
        printf(&#34;-&#34;);
        break;
    case 999:
        parse_opt(&#39;d&#39;, &#34;3&#34;, state);
        printf(&#34; &#34;);
        parse_opt(888, NULL, state);
        parse_opt(888, NULL, state);
        parse_opt(888, NULL, state);
        printf(&#34; &#34;);
        parse_opt(&#39;d&#39;, &#34;3&#34;, state);
        printf(&#34;\n&#34;);
        exit(0);
        break;
    case ARGP_KEY_ARG:
        argz_add(&amp;a-&gt;argz, &amp;a-&gt;argz_len, arg);
        break;
    case ARGP_KEY_INIT:
        a-&gt;argz = 0;
        a-&gt;argz_len = 0;
        break;
    case ARGP_KEY_END:
        {
            size_t count = argz_count(a-&gt;argz, a-&gt;argz_len);
            if(count&gt;2)
                argp_failure(state, 1, 0, &#34;too many arguments&#34;);
            else if(count&lt;1)
                argp_failure(state, 1, 0, &#34;too few arguments&#34;);
        }
        break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         {0, 0, 0, 0, &#34;Morse Code Options:&#34;, 7},
         {&#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34;},
         {&#34;dash&#34;, 888, 0, 0, &#34;Show a dash on the screen&#34;},
         {0, 0, 0, 0, &#34;Information Options:&#34;, -1},
         {&#34;SOS&#34;, 999, 0, 0, &#34;Give some help in morse code&#34;},
         { 0 }
        };
    struct argp argp = {options, parse_opt, &#34;WORD\nWORD WORD&#34;,
    &#34;Show some dots and dashes on the screen.\v&#34;
    &#34;A final newline is also shown regardless of whether any options were given.&#34;};
    struct arguments arguments;
    if(argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arguments) == 0) {
        const char *prev = NULL;
        char *word;
        while((word = argz_next(arguments.argz, arguments.argz_len, prev))) {
            printf(&#34; %s&#34;, word);
            prev = word;
        }
        printf(&#34;\n&#34;);
        free(arguments.argz);
    }
    return 0;
}</pre></div>
<p></details></p>

<p>结构体 <code>argp_option</code> 四条记录中只有两条记录指定了 <code>group</code> ，分别是 7 和 -1。这两条记录被称为头，通常的惯例是将其文本以冒号结尾。 <code>group</code> 字段被当作在帮助信息中用于排序选项的主键。拥有更大的非负数值的记录会排在更小的非负数值的记录之后。拥有负数值的记录排在非负值记录之后。小的负值记录排在大的负值记录之后。排序方式形如 <code>0 ,1, 2, ..., n, -m, ..., -2, -1</code> 。其他记录没有指定 <code>group</code> 字段。因为这些字段在头记录之后的记录中会自动设置。所以 <code>--dot</code> 和 <code>--dash</code> 自动接收到值 7。通常用法是对没有头的选项不设置该值。</p>

<p>组值为零且未出现在选项标题之后的选项将保持其零值，并出现在帮助输出中的所有其他选项之前。 如果我们在选项标题中省略了组值，则会自动将其设置为比前一个选项的组值大一个的值。 自动设置组值的目的是在简单的情况下不必提供组值。</p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">make step10

./step10 --help
Usage: step10 [OPTION...] WORD
  or:  step10 [OPTION...] WORD WORD
Show some dots and dashes on the screen.

 Morse Code Options:
  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen

 Information Options:
  -?, --help                 Give this help list
      --SOS                  Give some help in morse code
      --usage                Give a short usage message
  -V, --version              Print program version

A final newline is also shown regardless of whether any options were given.

Report bugs to someone@example.com.

./step10 -SOS
... --- ...</pre></div>
<p></details></p>

<p>可以看到莫尔斯密码选项都在同一组， <code>--dot</code> 选项出现在 <code>--dash</code> 选项之前，因为排序的第二个键是短选项，第三个键才是长选项。</p>

<p><code>--SOS</code> 选项也出现在了其他帮助信息中，因为默认选项也有 -1 的组值。</p>

<p><a id="org68f9698"></a></p>

<h2 id="step11-调用库">step11: 调用库</h2>

<p>可能有两个程序并且希望他们有相同的选项，argp 让这个实现变得简单，不需要复制代码。对于程序员而言，将程序中的函数压缩成一个库好让别的应用使用 api 来构建新应用。很多情况下 api 有一些配置元素，甚至是配置文件。程序员需要收集这些信息然后传递给 api。</p>

<p><details>
<summary> <code>dotdash.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &#34;dotdash.h&#34;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case &#39;d&#39;:
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&#34;.&#34;);
            break;
        }
        case 888:
            printf(&#34;-&#34;);
            break;
    }
    return 0;
}

static struct argp_option options[] =
{
    {&#34;dot&#34;, &#39;d&#39;, &#34;NUM&#34;, OPTION_ARG_OPTIONAL, &#34;Show some dots on the screen&#34;},
    {&#34;dash&#34;, 888, 0, 0, &#34;Show a dash on the screen&#34;},
    { 0 }
};

struct argp dotdash_argp = {options, parse_opt, 0, 0, 0};</pre></div>
<p></details></p>

<p>dotdash.h:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#ifndef DASHDOT_H
#define DASHDOT_H
#include &lt;argp.h&gt;
extern struct argp dotdash_argp;
#endif</pre></div>
<p><details>
<summary> <code>step11.c</code> </summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &#34;dotdash.h&#34;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 999:
            printf(&#34;...---...&#34;);
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
    {
        {&#34;SOS&#34;, 999, 0, 0, &#34;Show the SOS sequence on the screen&#34;},
        { 0 }
    };
    struct argp_child children_parsers[] =
    {
        {&amp;dotdash_argp. 0, &#34;Basic Morse Code Options:&#34;, 7},
        {0},
    };
    struct argp argp = {options, parse_opt, 0, 0, children_parsers};
    int retval = argp_parse(&amp;argp, argc, argv, 0, 0, 0);
    printf(&#34;\n&#34;);
    return retval;
}</pre></div>
<p></details></p>

<p><details>
<summary>编译运行</summary></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">cc -c -o dotdash.o dotdash.c

ar cr libdotdash.a dotdash.o

ranlib libdotdash.a

cc step11.c -L./ -ldotdash -o step11

./step11 --help
Usage: step11 [OPTION...]

      --SOS                  Show the SOS sequence on the screen

 Basic Morse Code Options:
  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen

  -?, --help                 Give this help list
      --usage                Give a short usage message</pre></div>
<p></details></p>

      </article>
  </div>
</section>

<aside>
    <h4 id="signature">
        Thu Nov 28, 2019
        
            cheon
        
    </h4>
    
    
    <ul class="tags">
      
        <li> <a href="https://www.cheon.site/blog/tags/library">library</a> </li>
      
    </ul>
    
    <ul class="related">
        
        <li><a class="previous" href="https://www.cheon.site/blog/c/low_level_io/"> Low Level I/O</a></li>
        
        
    </ul>
</aside>

        </div><section id="footer">

<div id="author">
    <h2>About Author</h2>
    <hr>
    <img src=https://www.cheon.site/images/author.jpg></img>
    <p>Life is dance we all have to do.</p>
</div>
<ul id="link">
    <li><a href=https://github.com/number317/aloha.git target="_blank"><i class="fa fa-github" alt="github"></i></a></li>
    <li><a href="mailto:cheon0112358d@gmail.com?subject=blog%27s%20feedback" target="_blank"><i class="fa fa-envelope" alt="email"></i></a></li>
    <li id="wechat"><i class="fa fa-wechat"></i></li>
    <img class="qrcode" src=https://www.cheon.site/images/wechat.jpg>
</ul>
</section>
</body>
</html>
