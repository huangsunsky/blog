<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rabbitmq on cheon&#39;s blog</title>
    <link>https://www.cheon.site/blog/tags/rabbitmq/</link>
    <description>Recent content in rabbitmq on cheon&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 30 Oct 2017 09:48:14 +0800</lastBuildDate>
    
	<atom:link href="https://www.cheon.site/blog/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rabbitmq Access Control</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_access_control/</link>
      <pubDate>Mon, 30 Oct 2017 09:48:14 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_access_control/</guid>
      <description>Rabbitmq 权限控制 在rabbitmq中，身份验证和授权是分开的。身份验证用于判断用户是谁，授权用于确定用户能做什么和不能做什么。
默认虚拟主机和用户 当服务第一次启动或者检测到数据库梅雨初始化或已经被删除，rabbitmq会初始化一个新的数据库，拥有如下资源：
 一个虚拟主机/ 一个用户名和密码都为guest的用户，拥有/虚拟主机的所有权限  建议是删除默认用户或者修改默认用户的密码。guest用户默认情况只能通过localhost连接，无法通过远程连接。这可以通过配置文件修改，设置loopback_users.guest = false即可。
权限工作方式 rabbitmq的权限控制主要分为两层，第一层是虚拟主机的权限，第二层是资源的权限。
虚拟主机(Virtual Host) 当客户端连接到服务器，它会指定一个要操作的虚拟主机，第一层权限控制被启用，服务器会检查用户对该虚拟主机是否有权限，没有权限连接会被拒绝。
示例：
首先创建一个用户：
rabbitmqctl add_user cheon 123 这里创建了一个用户cheon，密码为123（如果rabbitmq是集群，那么在集群中一个节点上创建了用户，虚拟主机等，在其他节点上也都会存在。）。刚创建的用户是没有任何权限的。可以确认一下用户的权限：
root@rabbitmq-node1:/# rabbitmqctl list_user_permissions cheon Listing permissions for user &amp;#34;cheon&amp;#34; ... root@rabbitmq-node1:/# rabbitmqctl list_user_permissions guest Listing permissions for user &amp;#34;guest&amp;#34; ... /	.*	.*	.* 可以看到新用户cheon没有任何权限，guest用户拥有虚拟主机/的全部权限。
编写一个简单的脚本，通过用户cheon连接/虚拟主机，发送Hello World：
#!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters(&amp;#39;172.17.0.6&amp;#39;, 5672, &amp;#34;/&amp;#34;, credentials=pika.PlainCredentials(&amp;#39;cheon&amp;#39;, &amp;#39;123&amp;#39;))) channel = connection.channel() channel.queue_declare(queue=&amp;#39;hello&amp;#39;) channel.basic_publish( exchange=&amp;#39;&amp;#39;, routing_key=&amp;#39;hello&amp;#39;, body=&amp;#39;Hello World!</description>
    </item>
    
    <item>
      <title>Rabbitmq Topic</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_topic/</link>
      <pubDate>Sun, 29 Oct 2017 20:32:52 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_topic/</guid>
      <description>rabbitmq 主题 虽然之前使用了direct交换来路由不同级别的日志，但是它无法做到根据设备来路由。在我们的日志系统中，可能不止是想要通过日志级别来订阅，还想通过日志来源订阅。这将会给我们带来更大的灵活性，比如我们可以只监听来自cron的error和来自kern的所有日志。为了达到这个效果，我们可以采用一个更复杂的交换&amp;ndash;topic。
Topic exchange 发送给topic交换的信息的routing_key的属性不能是任意的&amp;ndash;它必须是一个单词的列表，通过.分隔。单词可以是任意的，但是通常是一些描述信息特征的词语。例如stock.usd.nyse，nyse.vmw，quick.orange.rabbit。你可以设置任意多的词语，只要不超过255字节的限制。
binding key也必须是相同的格式。topic背后的交换逻辑和direct是相似的，一个带有特殊routing key的信息会被发送到所有拥有匹配binding key的队列，但有两个需要注意的地方：
 * 可以代表一个单词 # 可以代表0或多个单词  示例：
在这个示例中，我们发送描述动物的消息。消息会带有由三个单词组成的routing key，单词间用.分隔，用于描述不同的特征。我们创建了三个绑定：Q1和*.orange.*绑定，Q2和*.*.rabbit，lazy.#绑定。可以简单得概括为Q1只关心所有橙色的动物，Q2只关心兔子和慢吞吞的动物。
一条带有quick.orange.rabbit的routing key的信息会发送给两个队列，quick.orange.fox也会发送给两个，lazy.brown.fox只发送给Q2，lazy.pink.rabbit只发送给Q2一次，即使它匹配了两个绑定。quick.brown.fox不匹配任何绑定所以会被丢弃。如果我们发送的信息带有一个或四个单词，像orange，quick.orange.male.rabbit之类的，也不匹配任何绑定，也会被丢弃 。但是lazy.orange.male.rabbit虽然有四个单词，也匹配lazy.#，因为#代表0或多个单词，所以会被发送给Q2。
topic是一个强大的交换，可以实现其他交换的功能。当一个队列绑定#，它可以接收所有信息，就像fanout交换。当没有使用*和#，而是指定明确的字符串，就可以表现地像direct交换。
最终实现 我们假设日志的routing key有两个单词&amp;lt;facility&amp;gt;.&amp;lt;severity&amp;gt;，那么代码如下：
emit_log_topic.py：
#!/usr/bin/env python import pika import sys connection = pika.BlockingConnection(pika.ConnectionParameters(&amp;#39;172.17.0.6&amp;#39;, 5672, credentials=pika.PlainCredentials(&amp;#39;guest&amp;#39;, &amp;#39;guest&amp;#39;))) channel = connection.channel() channel.exchange_declare( exchange=&amp;#39;topic_logs&amp;#39;, exchange_type=&amp;#39;topic&amp;#39; ) severity = sys.argv[1] if len(sys.argv) &amp;gt; 2 else &amp;#39;info&amp;#39; message = &amp;#39; &amp;#39;.join(sys.argv[2:]) or &amp;#39;Hello World!&amp;#39; channel.basic_publish( exchange=&amp;#39;topic_logs&amp;#39;, routing_key=severity, body=message ) print(&amp;#34; [x] Sent %r:%r&amp;#34; % (severity, message)) connection.</description>
    </item>
    
    <item>
      <title>Rabbitmq Routing</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_routing/</link>
      <pubDate>Sat, 28 Oct 2017 09:26:49 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_routing/</guid>
      <description>Rabbitmq 路由 这里我们将为日志系统增加一个特性&amp;ndash;只订阅一部分信息。例如，我们可以将错误信息存入日志文件，将其他信息打印出来。
绑定（Bindings） 在日志系统中我们已经使用过绑定，像这样调用代码：
channel.queue_bind( exchange=exchange_name, queue=queue_name ) 一个绑定是交换和队列之间的关系，可以简单地理解为这个队列只对这个交换的信息感兴趣。绑定可以指定额外的routing_key参数。为了避免和一个basic_publish参数混淆，我们称它binding key，可以通过一下方式创建一个带有key的绑定：
channel.queue_bind( exchange=exchange_name, queue=queue_name, routing_key=&amp;#39;black&amp;#39; ) binding key的含义依赖于交换的类型。fanout交换类型会直接忽略这个值。
Direct exchange 我们之前的日志系统使用fanout交换类型，直接将信息广播给所有消费者。现在我们想要扩展它允许根据根据级别来过滤。例如，将错误级别的日志存入磁盘，将普通的日志直接输出而不浪费磁盘空间。为了达到这个目的，这里将使用direct交换。direct交换的路由算法也比较简单，一个消息只推送到binding key和routing key匹配的队列，举例如下图：
在上述例子中可以看到direct交换x有两个与之绑定的队列。第一个队列的binding key是orange，第二个队列有两个binding key，分别是black和green。通过这个配置，一个带有orage的routing key的信息推送到交换后会被路由到队列Q1；一个带有black或者green的routing key的信息推送到交换后会被路由到队列Q2，其他的信息会被丢弃。
多绑定（Muliple bindings） 用相同的binding key绑定多个队列完全是可行的。在我们的例子中可以在x和Q1之间添加一个名为black的binding key，这样的话，direct交换将会表现得像fanout并且会将信息广播到所有匹配的队列。一个带有black的routing key的信息会递送到Q1和Q2队列。
发送日志 我们将使用这个模型来构建日志系统，我们将会发送信息到direct交换，我们将会以日志的级别作为routing key。首先创建交换：
channel.exchange_declare( exchange=&amp;#39;direct_logs&amp;#39;, exchange_type=&amp;#39;direct&amp;#39; ) 然后发送消息：
channel.basic_publish( exchange=&amp;#39;direct_logs&amp;#39;, routing_key=serverity, body=message ) 为了简化程序，我们假设日志级别只有info，warning，error三种情况。
订阅 我们将为每一个需要的日志级别创建一个新的绑定：
result = channel.queue_declare(exclusive=True) queue_name = result.method.queue for severity in severities: channel.queue_bind( exchange=&amp;#39;direct_logs&amp;#39;, queue=queue_name, routing_key=severity ) 最终结果 emit_log_direct.py：
#!/usr/bin/env python import pika import sys connection = pika.</description>
    </item>
    
    <item>
      <title>Rabbitmq Publish Subscribe</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_publish_subscribe/</link>
      <pubDate>Fri, 27 Oct 2017 15:18:38 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_publish_subscribe/</guid>
      <description>Publish Subcribe 发布和订阅模式简单而言就是将一个消息发送个多个消费者。为了阐明这个模式，这里将会构建一个简单的日志系统，这个系统由两部分组成，第一个程序发送消息，第二个程序接收和打印消息。
在该日志系统中，接收程序的每一个运行副本都将得到消息，这样我们可以运行一个接收器，并将日志存放在磁盘；同时运行另一个接收器将日志在屏幕上打印出来。
交换(Exchanges) rabbitmq 消息模型的核心是生产者从不直接发送任何消息到队列。事实上，一个生产者经常不知道一个消息是否被发送到了队列。生产者只能将消息发送给交换。交换是一个非常简单的东西，它一边接收来自生产者的消息，另一边它把消息推入消息队列。交换是一定知道要怎么处理它接收到的消息的。应该被追加到一个特定的队列后，还是应该追加到多个队列中，还是应该被丢弃。这些规则都由交换类型（exchange type）定义。
有一些可用的交换类型：direct, topic, headers 和 fanout，这里将使用最后一个类型&amp;ndash;fanout。创建一个名为logs的该类型交换：
channel.exchange_declare(exchange=&amp;#39;logs&amp;#39;, exchange_type=&amp;#39;fanout&amp;#39;) fanout类型的交换非常简单。就如它的名字一样，它只是将它接收到的信息广播到它知道的所有队列，这正是我们日志系统所需要的。
查看交换 列出服务器上可用的交换可以使用rabbitmqctl命令:
rabbitmqctl list_exchanges 在列表中会有一些amq.*的交换和默认（未命名）的交换。这些是默认配置的，但是这里目前用不到他们。
有时候我们通过空字符串&#39;&#39;来使用默认的交换：
channel.basic_publish(exchange=&amp;#39;&amp;#39;, routing_key=&amp;#39;hello&amp;#39;, body=message) 现在我们可以推送到我们的命名交换中：
channel.basic_publish( exchange=&amp;#39;logs&amp;#39; routing_key=&amp;#39;&amp;#39;, body=message ) 临时队列 有时我们使用的队列有指定的名字，能够为队列命名是至关重要的，我们需要指定工作到相同的队列。当你想要在生产者和消费者间共享队列时为队列命名是很重要的。但是在我们的日志系统中，我们想要监听所有的日志，而不是一些；我们也只对当前流动的信息感兴趣而不是旧的信息。要达到这个效果我们需要两件事。
第一，无论何时连接到rabbitmq我们需要刷新，清空队列。为了做到这个我们可以用随机名字创建一个队列，或者更好的是让服务器为我们选择一个随机的队列名字。可以通过不给queue参数到queue_declare来做到这一点：
result = channel.queue_declare() 这个时候result.method.queue包含了一个随机的队列名。例如它可能看起来像amq.gen-JzTY20BRgKO-HjmUJj0wLg
第二，一旦消费者连接被关闭，队列应该被删除，有一个exclusive标签：
result = channel.queue_declare(excusive=True) 可以在队列指南获取更多exclusive标签和其他队列属性。
绑定（Bindings） 我们已经创建了一个fanout类型的交换。现在我们需要告诉交换发送信息给我们的队列。交换和队列之间的关系叫做绑定：
channel.queue_bind(exchange=&amp;#39;logs&amp;#39;, queue=result.method.queue) 现在logs交换将会追加信息到我们的队列。
列出绑定 可以列出当前存在的绑定：
rabbitmqctl list_bindings 最终代码如下
生产者emit_log.py：
#!/usr/bin/env python import pika import sys connection = pika.BlockingConnection(pika.ConnectionParameters(&amp;#39;172.17.0.6&amp;#39;, 5672, credentials=pika.PlainCredentials(&amp;#39;guest&amp;#39;, &amp;#39;guest&amp;#39;))) channel = connection.channel() channel.</description>
    </item>
    
    <item>
      <title>Rabbitmq Work Queue</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_work_queue/</link>
      <pubDate>Thu, 26 Oct 2017 19:06:17 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_work_queue/</guid>
      <description>&lt;h1 id=&#34;work-queue&#34;&gt;Work Queue&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://www.cheon.site/blog/struct/images/rabbitmq_work_queue_img1.png&#34; alt=&#34;Work Queue 架构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;工作队列背后的思想是尽量避免立即做资源密集型任务并等待它完成，而是将这些任务放到计划表中，等会儿完成。我们将一个任务封装为一条信息并把它送入一个队列。一个在后台运行的进程将会弹出这些任务并最终执行这个工作。当你运行很多个进程时，任务将会被他们共享。这个概念在web应用中尤为有用，因为在一个简短的HTTP请求中不太可能去处理过于复杂的任务。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rabbitmq Hello World</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_hello_world/</link>
      <pubDate>Thu, 26 Oct 2017 17:17:47 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_hello_world/</guid>
      <description>&lt;h1 id=&#34;hello-world&#34;&gt;Hello World&lt;/h1&gt;

&lt;p&gt;我们将用python写两个简单的程序，一个生产者发送一条信息，一个消费者接受并打印信息。图中的&amp;rdquo;P&amp;rdquo;指代生产者，&amp;rdquo;C&amp;rdquo;指代消费者，中间的盒子指代一个队列——RabbitMQ 的一个消息缓存。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rabbitmq Cluster</title>
      <link>https://www.cheon.site/blog/struct/rabbitmq_cluster/</link>
      <pubDate>Thu, 26 Oct 2017 16:28:26 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/struct/rabbitmq_cluster/</guid>
      <description>&lt;h1 id=&#34;rabbitmq-docker-运行&#34;&gt;RabbitMQ docker 运行&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -d -p 15672:15672 -p 5672:5672 --hostname rabbit --name rabbit -e &lt;span style=&#34;color:#666;font-weight:bold;font-style:italic&#34;&gt;TZ&lt;/span&gt;=Asia/Shanghai -e &lt;span style=&#34;color:#666;font-weight:bold;font-style:italic&#34;&gt;RABBITMQ_DEFAULT_USER&lt;/span&gt;=admin -e &lt;span style=&#34;color:#666;font-weight:bold;font-style:italic&#34;&gt;RABBITMQ_DEFAULT_PASS&lt;/span&gt;=admin rabbitmq:3-management&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>