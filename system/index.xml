<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello linux on cheon&#39;s blog</title>
    <link>https://www.cheon.site/blog/system/</link>
    <description>Recent content in Hello linux on cheon&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 May 2019 14:55:56 +0800</lastBuildDate>
    
	<atom:link href="https://www.cheon.site/blog/system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Archlinux Nvidia</title>
      <link>https://www.cheon.site/blog/system/archlinux_nvidia/</link>
      <pubDate>Sun, 29 Sep 2019 14:07:53 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/archlinux_nvidia/</guid>
      <description>Table of Contents  ArchLinux 配置 nvidia 独立显卡 firefox webgl 配置独立显卡  
ArchLinux 配置 nvidia 独立显卡 按照 PRIME Render Offload 文档，安装新版本的 nvidia 驱动和 xorg，新版本的 xorg 安装包可以从 arch-xorg-server 构建。 修改配置文件 /etc/X11/xorg.conf ，主要添加
Section &amp;#34;ServerLayout&amp;#34; Identifier &amp;#34;layout&amp;#34; Option &amp;#34;AllowNVIDIAGPUScreens&amp;#34; EndSection 完整配置如下:
 xorg.conf
Section &amp;#34;ServerLayout&amp;#34; Identifier &amp;#34;X.org Configured&amp;#34; Screen 0 &amp;#34;Screen0&amp;#34; 0 0 #Screen 1 &amp;#34;Screen1&amp;#34; RightOf &amp;#34;Screen0&amp;#34; InputDevice &amp;#34;Mouse0&amp;#34; &amp;#34;CorePointer&amp;#34; InputDevice &amp;#34;Keyboard0&amp;#34; &amp;#34;CoreKeyboard&amp;#34; Option &amp;#34;AllowNVIDIAGPUScreens&amp;#34; EndSection Section &amp;#34;Files&amp;#34; ModulePath &amp;#34;/usr/lib/xorg/modules&amp;#34; ModulePath &amp;#34;/usr/lib/modules/extramodules-ARCH&amp;#34; FontPath &amp;#34;/usr/share/fonts/TTF&amp;#34; FontPath &amp;#34;/usr/share/fonts/adobe-source-code-pro&amp;#34; EndSection Section &amp;#34;Module&amp;#34; Load &amp;#34;glx&amp;#34; Load &amp;#34;nvidia-drm&amp;#34; EndSection Section &amp;#34;InputDevice&amp;#34; Identifier &amp;#34;Keyboard0&amp;#34; Driver &amp;#34;kbd&amp;#34; EndSection Section &amp;#34;InputDevice&amp;#34; Identifier &amp;#34;Mouse0&amp;#34; Driver &amp;#34;mouse&amp;#34; Option	&amp;#34;Protocol&amp;#34; &amp;#34;auto&amp;#34; Option	&amp;#34;Device&amp;#34; &amp;#34;/dev/input/mice&amp;#34; Option	&amp;#34;ZAxisMapping&amp;#34; &amp;#34;4 5 6 7&amp;#34; EndSection Section &amp;#34;Monitor&amp;#34; Identifier &amp;#34;Monitor0&amp;#34; VendorName &amp;#34;Monitor Vendor&amp;#34; ModelName &amp;#34;Monitor Model&amp;#34; EndSection Section &amp;#34;Device&amp;#34; ### Available Driver options are:- ### Values: &amp;lt;i&amp;gt;: integer, &amp;lt;f&amp;gt;: float, &amp;lt;bool&amp;gt;: &amp;#34;True&amp;#34;/&amp;#34;False&amp;#34;, ### &amp;lt;string&amp;gt;: &amp;#34;String&amp;#34;, &amp;lt;freq&amp;gt;: &amp;#34;&amp;lt;f&amp;gt; Hz/kHz/MHz&amp;#34;, ### &amp;lt;percent&amp;gt;: &amp;#34;&amp;lt;f&amp;gt;%&amp;#34; ### [arg]: arg optional #Option &amp;#34;SWcursor&amp;#34; # [&amp;lt;bool&amp;gt;] #Option &amp;#34;kmsdev&amp;#34; # &amp;lt;str&amp;gt; #Option &amp;#34;ShadowFB&amp;#34; # [&amp;lt;bool&amp;gt;] #Option &amp;#34;AccelMethod&amp;#34; # &amp;lt;str&amp;gt; #Option &amp;#34;PageFlip&amp;#34; # [&amp;lt;bool&amp;gt;] #Option &amp;#34;ZaphodHeads&amp;#34; # &amp;lt;str&amp;gt; #Option &amp;#34;DoubleShadow&amp;#34; # [&amp;lt;bool&amp;gt;] Option &amp;#34;RenderAccel&amp;#34; &amp;#34;1&amp;#34; Option &amp;#34;DPMS&amp;#34; &amp;#34;1&amp;#34; Option &amp;#34;RegistryDwords&amp;#34; &amp;#34;EnableBrightnessControl=1&amp;#34; Identifier &amp;#34;Card0&amp;#34; Driver &amp;#34;modesetting&amp;#34; BusID &amp;#34;PCI:0:2:0&amp;#34; EndSection Section &amp;#34;Device&amp;#34; Identifier &amp;#34;Card1&amp;#34; Driver &amp;#34;nvidia&amp;#34; BusID &amp;#34;PCI:1:0:0&amp;#34; Option &amp;#34;RenderAccel&amp;#34; &amp;#34;1&amp;#34; Option &amp;#34;DPMS&amp;#34; &amp;#34;1&amp;#34; Option &amp;#34;RegistryDwords&amp;#34; &amp;#34;EnableBrightnessControl=1&amp;#34; Option &amp;#34;RegistryDwords&amp;#34; &amp;#34;PowerMizerLevelAC=0x3&amp;#34; Option &amp;#34;RegistryDwords&amp;#34; &amp;#34;PowerMizerLevel=0x2&amp;#34; Option &amp;#34;RegistryDwords&amp;#34; &amp;#34;PerfLevelSrc=0x3333&amp;#34; Option &amp;#34;OnDemandVBlankInterrupts&amp;#34; &amp;#34;1&amp;#34; EndSection Section &amp;#34;Screen&amp;#34; Identifier &amp;#34;Screen0&amp;#34; Device &amp;#34;Card0&amp;#34; Monitor &amp;#34;Monitor0&amp;#34; SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 1 EndSubSection SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 4 EndSubSection SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 8 EndSubSection SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 15 EndSubSection SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 16 EndSubSection SubSection &amp;#34;Display&amp;#34; Viewport 0 0 Depth 24 EndSubSection EndSection</description>
    </item>
    
    <item>
      <title>Nerd Font</title>
      <link>https://www.cheon.site/blog/system/nerd_font/</link>
      <pubDate>Fri, 21 Jun 2019 14:32:35 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/nerd_font/</guid>
      <description>图标字体 在用 dzen2 给桌面添加一个 panel 的时候用到了 FontAwesome，但是在 urxvt 终端下 FontAwesome 无法正常显示出来（不知是不是配置有误）。这样在用 vim 写脚本时不够直观。又不想换终端，所以只能从字体下手。
之前就了解到过 nerd-fonts 这个项目，可以将图标字体整合进一个你想要的字体中。项目主页提供了一些已经预先构建好的字体，可以在官网直接下载使用。目前终端用的字体是从另一台 Mac 上复制出来的 SFMono，这也是 Mac 内置终端默认的字体。已经习惯了这款字体后就不想换了，因此准备构建自己的字体。
根据项目主页的教程，执行它提供给你的 font-patcher 脚本前需要安装 fontforge:
pacman -S fontforge 安装完依赖，下载 font-patcher 脚本并添加可执行权限:
curl -OL https://raw.githubusercontent.com/ryanoasis/nerd-fonts/master/font-patcher chmod +x font-patcher 执行脚本进行构建字体:
./font-patcher path/to/SFMono-Regular.otf -out path/to/SFMono-Nerd/ -c -l -s  -c 表示添加所有可用字形 -l 表示适应行高（尝试将 powerline 的分隔符均匀地放在中间） -s 表示使用单个字符宽度  运行脚本发现报错，提示找不到 src 目录下的字体文件。这提示我们还需要去下载 src 目录下的字体文件。这里有一个技巧，关于如何从 github 下载某个文件夹。
以此处为例，需要下载https://github.com/ryanoasis/nerd-fonts/tree/master/src/glyphs目录下的所有字体文件。可以将 url 中的 &amp;ldquo;tree/master&amp;rdquo; 替换为 ”trunk“，再用 svn 去下载就好了。</description>
    </item>
    
    <item>
      <title>Vps Openvpn</title>
      <link>https://www.cheon.site/blog/system/vps_openvpn/</link>
      <pubDate>Sat, 28 Apr 2018 15:22:21 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/vps_openvpn/</guid>
      <description>VPS OpenVPN 翻墙教程 服务端配置 首先，需要一台能访问外网的服务器。这里采用的是HostUS的VPS。
在部署OpenVPN服务端之前，应该先打开服务器的ip转发功能。修改/etc/sysctl.conf文件，将对应内容修改为下面一行的值：
net.ipv4.ip_forward = 1 修改后执行sysctl -p /etc/sysctl.conf使配置生效。
服务端采用容器部署，因此VPS应该先安装好docker。以下为容器启动脚本：
#!/bin/bash IP=&amp;#34;xxx.xxx.xxx.xxx&amp;#34; OVPN_DATA=&amp;#34;/root/ovpn_data&amp;#34; docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://$IP docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki docker run -v $OVPN_DATA:/etc/openvpn --name openvpn -e DEBUG=1 -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME nopass docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient CLIENTNAME &amp;gt; CLIENTNAME.ovpn 将上述脚本的IP地址替换为自己的IP地址，然后执行脚本，根据提示输入信息即可。中间要求输入密码之类的都写个简单点一样的密码就好。
脚本执行完成后会生成一个CLIENTNAME.ovpn客户端的配置文件，将它下载到自己的电脑上，用于配置客户端。</description>
    </item>
    
    <item>
      <title>Iptables Intro</title>
      <link>https://www.cheon.site/blog/system/iptables_intro/</link>
      <pubDate>Thu, 26 Apr 2018 08:32:31 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/iptables_intro/</guid>
      <description>iptables 介绍 基本概念  iptables 可以检测、修改、转发、重定向和丢弃IPV4数据包。 表(tables)  raw: 用于配置数据包 filter: 存放所有与防火墙相关操作的表 nat: 用于网络地址转换 mangle: 用于对特定数据包的修改 security: 用于强制访问控制  链(chains): INPUT, OUTPUT, FORWARD, PREROUTING,POSTROUTING 规则(rules): 过滤数据包 模块(modules): 用于扩展iptables，进行更复杂的过滤  工作流程 第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 INPUT 链），还是其他主机（数据包穿过 FORWARD 链）；
中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；
最后一个路由策略存在是因为 mangle 与 nat 链可能会改变数据包的路由信息。
数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target/jump 动作将会执行。最常用的3个 target 是 ACCEPT, DROP ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包返回到调用链。在任何时候，若 DROP target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 ACCEPT，那么它也会被所有的父链 ACCEPT，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。
常用选项    参数类型 可选项     表 filter, nat&amp;hellip;   链 INPUT, OUTPUT, FORWARD, PREOUTING（修改目标ip地址）, POSTROUTING（修改源ip地址）&amp;hellip;   匹配属性 源、目标IP，协议（TCP,UDP,ICMP&amp;hellip;），端口号，网卡接口&amp;hellip;   模块 conntrack, multiport, connlimit&amp;hellip;   动作 ACCEPT, DROP, RETURN, REJECT&amp;hellip;    配置运行 # systemctl start iptables 启动时会读取/etc/iptables/iptables.</description>
    </item>
    
    <item>
      <title>Dell Xps 15 9560 Arch Linux Install</title>
      <link>https://www.cheon.site/blog/system/dell_xps_15_9560_arch_linux_install/</link>
      <pubDate>Wed, 28 Mar 2018 10:18:12 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/dell_xps_15_9560_arch_linux_install/</guid>
      <description>Dell XPS 15 9560 Arch Linux 安装教程 BIOS设置 打开电脑，等待出现dell图标时按下F12键，选择进入BIOS设置页面，进行如下操作
 将SATA Mode从默认的RAID模式修改为AHCI模式。这样可以允许Linux检测到NVME SSD。 将Fastboot的选项从POST Behaviour修改为Thorough，这样可以防止偶尔的启动错误。 关闭安全启动来允许linux启动。  保存后退出，会重启电脑。
内核启动参数设置 从U盘启动 Arch Linux 引导镜像：在dell图标出现时按下F12，选择从U盘启动，在出现启动菜单时，按下e键，添加以下启动参数：
initrd=\initramfs-linux.img root=/dev/sdb2 acpi_rev_override=1 pci=nommconf nouveau.modeset=0 这样可以保证系统可以正常关闭和重启，否则关闭和重启时电脑会死机。
系统安装 tty字体设置 首先由于4k屏的高分辨率，使得终端字体非常小，应该设置大一点的字体：
setfont latarcyrheb-sun32 网络连接 wifi-menu 根据提示选择wifi，输入密码即可。
分区 这里采用lvm并使用cryptsetup来加密磁盘，最终分区如下：
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT nvme0n1 259:0 0 477G 0 disk ├─nvme0n1p1 259:1 0 512M 0 part /boot └─nvme0n1p2 259:2 0 476.4G 0 part └─luks 254:0 0 476.4G 0 crypt ├─entropy--vg0-root 254:1 0 150G 0 lvm / ├─entropy--vg0-home 254:2 0 250G 0 lvm /home ├─entropy--vg0-swap 254:3 0 16G 0 lvm [SWAP] └─entropy--vg0-backup 254:4 0 10G 0 lvm  磁盘创建两个分区，一个分区用于/boot，另一个分区用于安装系统。</description>
    </item>
    
    <item>
      <title>Lvm Intro</title>
      <link>https://www.cheon.site/blog/system/lvm_intro/</link>
      <pubDate>Fri, 26 Jan 2018 15:27:50 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/lvm_intro/</guid>
      <description>LVM 介绍 LVM(Logical Volume Management)逻辑卷管理利用linux内核的device-mapper特征来实现存储系统的虚拟化，操作系统不再直接操作磁盘，而是操作LV(Logical Volume)逻辑卷。
传统磁盘管理如GPT分区和MBR分区存在着磁盘分区无法动态扩展的缺点，即是增加新的磁盘也只能当作单独的文件系统使用，而无法为已在使用的分区增加空间。LVM正好解决了这个问题，可以动态地为分区扩容，而不影响上层系统的使用。
LVM 基本概念  PE(Physical Extend)：物理区域&amp;ndash;逻辑卷管理的最小单位，默认大小为4M PV(Physical Volume)：物理卷&amp;ndash;建立卷组的媒介，可以是磁盘，分区或者回环文件，物理卷包括一个特殊的header，其余部分被切割为一块块物理区域(physical extents) VG(Volume Group)：卷组&amp;ndash;物理卷组成的组，可以被认为是PE池 LV(Logical Volume)：逻辑卷&amp;ndash;虚拟分区，由PE组成。组成LV的PE可以来自不同的磁盘  LVM 工作流程 构造逻辑卷LV主要有3个步骤：
 将磁盘或分区条带化为PV(物理卷)，实际上是将磁盘或分区分割成一个个PE(物理区域)，默认大小是4M 将PV组合成VG，VG中的PE供LV使用，创建VG时需要给VG命名，/dev/目录下会生成一个以VG名字命名的文件夹 基于VG创建LV，LV也需要命名，LV创建好后会在对应的卷组目录下创建一个一LV名字命名的设备，该设备呈现给操作系统使用，可以格式化，当作正常的分区使用。  Physical disks Disk1 (/dev/sda): _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |Partition1 50GB (Physical Volume) |Partition2 80GB (Physical Volume) | |/dev/sda1 |/dev/sda2 | |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | Disk2 (/dev/sdb): _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |Partition1 120GB (Physical Volume) | |/dev/sdb1 | | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _| LVM logical volumes Volume Group1 (/dev/MyStorage/ = /dev/sda1 + /dev/sda2 + /dev/sdb1): _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |Logical volume1 15GB |Logical volume2 35GB |Logical volume3 200GB | |/dev/MyStorage/rootvol|/dev/MyStorage/homevol |/dev/MyStorage/mediavol | |_ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | 如上图中有/dev/sda，/dev/sdb两个磁盘，sda有sda1和sda2两个分区，sdb有sdb1一个分区，三个分区都被条带化成了PV。三个PV组成了一个VG，名字是MyStorage，基于这个VG创建了三个LV，分别叫做rootvol，homevol，mediavol，在/dev/目录下也创建了相应的文件夹和设备。</description>
    </item>
    
    <item>
      <title>Redhat Enable Ipv6</title>
      <link>https://www.cheon.site/blog/system/redhat_enable_ipv6/</link>
      <pubDate>Fri, 26 Jan 2018 14:43:54 +0800</pubDate>
      
      <guid>https://www.cheon.site/blog/system/redhat_enable_ipv6/</guid>
      <description>RedHat设置开机启用ipv6 参照的系统信息：
$ lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: RedHatEnterpriseServer Description: Red Hat Enterprise Linux Server release 7.3 (Maipo) Release: 7.3 Codename: Maipo 首先查看系统是否开启了ipv6：
ifconfig | grep inet 或者
ip addr | grep inet 如果开启了，则应该有ipv6的字段：
inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic eth0 inet6 fe80::a00:27ff:fe3a:b67/64 scope link inet 192.168.33.10/24 brd 192.168.33.255 scope global eth1 inet6 fe80::a00:27ff:fef4:9024/64 scope link inet 172.</description>
    </item>
    
  </channel>
</rss>